#!/usr/bin/env python

import readline
import getpass
import shlex
import httplib2
import rdflib
import pynappl

class CommandDispatcher(object):
	def __init__(self):
		self.client = httplib2.Http()
		self.store = None
		self.prefixes = {
			"rdf": "http://www.w3.org/1999/02/22-rdf-syntax-ns#",
			"rdfs": "http://www.w3.org/2000/01/rdf-schema#",
			"dc": "http://purl.org/dc/elements/1.1/",
			"dct": "http://purl.org/dc/terms",
			"owl": "http://www.w3.org/2002/07/owl#",
			"cs": "http://purl.org/vocab/changeset/schema#",
			"foaf": "http://xmlns.com/foaf/0.1/",
			"geo": "http://www.w3.org/2003/01/geo/wgs84_pos#",
			"rel": "http://purl.org/vocab/relationship/",
			"skos": "http://www.w3.org/2004/02/skos/core#",
			"bibo": "http://purl.org/ontology/bibo/",
			"ov": "http://open.vocab.org/terms/",
			"void": "http://rdfs.org/ns/void#",
			"xsd": "http://www.w3.org/2001/XMLSchema#",
			"dbp": "http://dbpedia.org/resource/",
			"dbpo": "http://dbpedia.org/ontology/",
		}
	
	def __call__(self, words):
		name = "handle_" + words[0].lower()
		if hasattr(self, name):
			getattr(self, name)(*words[1:])
	
	def execute(self, func, *args, **kwds):
		while True:
			response, body = func(*args, **kwds)
			if response.status in range(200, 300):
				return body
			elif response.status == 401:
				print "Unauthorized"
				self.handle_login()
				continue
			else:
				print "Request failed: %d %s - %s" % (response.status, response.reason, body)
				return None
	
	def bind_prefixes(self, g):
		for prefix, ns in self.prefixes.iteritems():
			g.bind(prefix, ns)
	
	def geturi(self, v):
		if v[0] == "<" and v[-1] == ">":
			return rdflib.URIRef(v[1:-1])
		else:
			prefix, name = v.split(":")
			return rdflib.URIRef(self.prefixes[prefix] + name)

	def getval(self, v):
		if v[0] in "\"'":
			lang = dt = None
			if v[-1] != v[0]:
				if "@" in v:
					v, lang = v.rsplit("@", 1)
				elif "^^" in v:
					v, dt = v.rsplit("^^", 1)
			s = v[1:-1]
			return rdflib.Literal(s, lang, dt)
		elif v[:2] == "_:":
			return rdflib.BNode(v[2:])
		else:
			return self.geturi(v)
	
	def handle_login(self, un=None):
		if not un:
			un = raw_input("Username: ")
		pw = getpass.getpass("Password: ")
		self.client.clear_credentials()
		self.client.add_credentials(un, pw)
	
	def handle_use(self, store=None):
		if store is None:
			store = raw_input("Store: ")
		self.store = pynappl.Store(store, client=self.client)
	
	def handle_store(self, filename):
		if self.store is None:
			self.handle_use()
		self.execute(self.store.store_file, filename)
	
	def handle_describe(self, uri):
		if self.store is None:
			self.handle_use()
		g = self.execute(self.store.describe, self.geturi(uri))
		self.bind_prefixes(g)
		if g:
			print g.serialize(format="turtle")
	
	def handle_add(self, s, p, o, changeReason="", creatorName="TConsole"):
		if self.store is None:
			self.handle_use()
		s = self.getval(s)
		p = self.getval(p)
		o = self.getval(o)
		cs = pynappl.Changeset(s)
		cs.setChangeReason(changeReason)
		cs.setCreatorName(creatorName)
		cs.add(p, o)
		body = cs.serialize(format="xml")
		uri = self.store.build_uri("/meta")
		headers = {"Content-Type": "application/vnd.talis.changeset+xml"}
		self.execute(self.client.request, uri, "POST", body, headers)
	
	def handle_remove(self, s="-", p="-", o="-", changeReason="", creatorName="TConsole"):
		if self.store is None:
			self.handle_use()
		vars = []
		if s == "-":
			s = "?s"
			vars.append(s)
		if p == "-":
			p = "?p"
			vars.append(p)
		if o == "-":
			o = "?o"
			vars.append(o)
		print "Querying data..."
		query = "SELECT %s WHERE {%s %s %s.}" % (" ".join(vars), s, p, o)
		results = self.execute(self.store.select, query)
		if results:
			if s not in vars:
				s = self.getval(s)
			if p not in vars:
				p = self.getval(p)
			if o not in vars:
				o = self.getval(o)
			cs = pynappl.BatchChangeSet()
			cs.setChangeReason(changeReason)
			cs.setCreatorName(creatorName)
			for d in results[1]:
				for h, v in d.iteritems():
					if h == "s":
						s = v
					elif h == "p":
						p = v
					elif h == "o":
						o = v
				cs.remove(s, p, o)
			headers = {"Content-Type": "application/vnd.talis.changeset+xml"}
			uri = self.store.build_uri("/meta")
			graphs = list(cs.getGraphs())
			nGraphs = len(graphs)
			for i, g in enumerate(graphs):
				body = g.serialize(format="xml")
				print "Applying changeset %d/%d (%d bytes)..." % (i + 1, nGraphs, len(body))
				self.execute(self.client.request, uri, "POST", body, headers)
	
	def handle_prefix(self, prefix, ns):
		self.prefixes[prefix] = self.geturi(ns)
	
	def handle_show(self, what):
		if what.lower() == "prefixes":
			for prefix, ns in self.prefixes.iteritems():
				print "%s: <%s>" % (prefix, ns)
	
	def handle_sparql(self, query):
		if self.store is None:
			self.handle_use()
		cmd = query.split()[0].upper()
		if cmd == "SELECT":
			results = self.execute(self.store.select, query)
			if results:
				headers, results = results
				sizes = {}
				for h in headers:
					sizes[h] = len(h)
				for d in results:
					for h, v in d.iteritems():
						sizes[h] = max(sizes[h], len(v))
				headerparts = []
				sep = []
				for h in headers:
					headerparts.append(h.center(sizes[h]))
					sep.append("=" * sizes[h])
				print " | ".join(headerparts)
				print "=+=".join(sep)
				for d in results:
					line = []
					for h, v in d.iteritems():
						line.append(str(v).center(sizes[h]))
					print " | ".join(line)
		elif cmd == "ASK":
			res = self.execute(self.store.ask, query)
			if res is True:
				print "Yes"
			elif res is False:
				print "No"
		else:
			body = self.execute(self.store.sparql, query)
			if body:
				g = rdflib.ConjunctiveGraph()
				g.parse(body)
				print g.serialize(format="turtle")
	
	def handle_search(self, query):
		if self.store is None:
			self.handle_use()
		results = self.execute(self.store.search, query)
		if results:
			for result in results:
				print str(result)
	
	def handle_fpmap(self):
		if self.store is None:
			self.handle_use()
		fpmap = self.execute(self.store.read_fpmap)
		if fpmap is not None:
			modified = False
			while True:
				line = raw_input("fpmap%s> " % (modified and "*" or ""))
				words = shlex.split(line)
				cmd = words[0].lower()
				if cmd in ("exit", "quit"):
					if modified:
						if raw_input("Exit without saving changes? (y/n) ") != "y":
							self.execute(self.store.write_fpmap, fpmap)
					return
				elif cmd == "save":
					if self.store.write_fpmap(fpmap) is not None:
						modified = False
				elif cmd == "view":
					for prop, d in fpmap.mappings().iteritems():
						print prop, "->", d["name"]
				elif cmd == "add":
					prop = self.geturi(words[1])
					name = words[2]
					fpmap.add_mapping(prop, name)
					modified = True
				elif cmd == "remove":
					prop = self.geturi(words[1])
					fpmap.remove_mapping(prop)
				elif cmd == "prefix":
					prefix = words[1]
					ns = self.geturi(words[2])
					self.prefixes[prefix] = ns

def main():
	d = CommandDispatcher()
	while True:
		line = raw_input(">>> ")
		words = shlex.split(line)
		if words[0].lower() in ("exit", "quit"):
			return
		d(words)

if __name__ == "__main__":
	main()
